/**
 * ENHANCED SUPPLY CHAIN MANAGEMENT DATA GENERATOR WITH REALISTIC DATA QUALITY ISSUES
 * Generates 6 interconnected datasets with intentional data quality problems that mirror real-world scenarios
 *
 * DATA QUALITY ISSUES INTRODUCED:
 * - Inconsistent name formatting (ALL CAPS, Mixed Case, extra spaces)
 * - Missing/NULL values in non-critical fields
 * - Duplicate entries with slight variations
 * - Inconsistent email formats and domains
 * - Phone number format variations
 * - Spelling mistakes and typos
 * - Mixed date formats
 * - Inconsistent category naming
 * - Price inconsistencies
 * - Status field variations
 *
 * Paste this into a single Apps Script file (Code.gs) and run `onOpen` (or reload sheet).
 */

// ==============================================================================
// CONFIGURATION & SETUP
// ==============================================================================
const CONFIG = {
  SUPPLIERS_COUNT: 50000,
  PRODUCTS_COUNT: 50000,
  WAREHOUSES_COUNT: 50000,
  INVENTORY_COUNT: 50000,
  RETAIL_STORES_COUNT: 50000,
  SUPPLY_ORDERS_COUNT: 50000,
  BATCH_SIZE: 1000,
  SHEET_NAMES: {
    SUPPLIERS: 'Suppliers',
    PRODUCTS: 'Products',
    WAREHOUSES: 'Warehouses',
    INVENTORY: 'Inventory',
    RETAIL_STORES: 'RetailStores',
    SUPPLY_ORDERS: 'SupplyOrders'
  },
  SEED: null,

  // DATA QUALITY CONFIGURATION
  DATA_QUALITY: {
    MISSING_VALUE_RATE: 0.05,        // 5% chance of missing values in optional fields
    DUPLICATE_RATE: 0.02,            // 2% chance of creating duplicates
    TYPO_RATE: 0.03,                 // 3% chance of introducing typos
    FORMAT_INCONSISTENCY_RATE: 0.15, // 15% chance of format inconsistencies
    CASE_INCONSISTENCY_RATE: 0.20,   // 20% chance of case inconsistencies
    EXTRA_SPACES_RATE: 0.10,         // 10% chance of extra spaces
    PRICE_INCONSISTENCY_RATE: 0.05   // 5% chance of price issues
  }
};

// ==============================================================================
// SAMPLE DATA (INDIANIZED + ENHANCED SCHEMA)
// ==============================================================================

const SUPPLIER_PREFIXES = [
  'Bharat','Shakti','Surya','Hindustan','Navratna','Rajdhani','Vikas','Sangam','Triveni','Uday',
  'Samrat','Mangal','Krishna','Shree','Annapurna','Sundaram','Ashoka','Chanakya','Arya','Amrit',
  'Dakshin','Uttar','Purva','Paschim','Deccan','Vindhya','Sahyadri','Malwa','Ganga','Yamuna',
  'Narmada','Kaveri','Godavari','Satpura','Himalaya','Nilgiri','Konark','Ajanta','Ellora','Somnath',
  'Dwarka','Ayodhya','Nalanda','Takshashila','Kosala','Magadha','Avanti','Kalinga','Sanchi','Lumbini'
];

// Enhanced product categories with subcategories
const PRODUCT_CATEGORIES = {
  'Electronics': ['Televisions', 'Mobile Phones', 'Laptops', 'Audio Systems', 'Gaming Consoles', 'Smart Watches'],
  'Mechanical Parts': ['Bearings', 'Gears', 'Valves', 'Pumps', 'Motors', 'Hydraulics'],
  'Raw Materials': ['Steel', 'Aluminum', 'Plastics', 'Chemicals', 'Textiles', 'Wood'],
  'Office Supplies': ['Stationery', 'Furniture', 'Computing', 'Storage', 'Printing', 'Communication'],
  'Industrial Tools': ['Hand Tools', 'Power Tools', 'Measuring', 'Cutting', 'Welding', 'Safety'],
  'Safety Gear': ['Head Protection', 'Body Protection', 'Foot Protection', 'Eye Protection', 'Respiratory', 'Fall Protection'],
  'Automotive Parts': ['Engine Parts', 'Braking Systems', 'Electrical', 'Body Parts', 'Filters', 'Tires'],
  'Textiles': ['Cotton', 'Silk', 'Synthetic', 'Wool', 'Linen', 'Blends'],
  'FMCG': ['Personal Care', 'Food & Beverages', 'Household', 'Health & Wellness', 'Baby Care', 'Pet Care'],
  'Packaging': ['Cardboard', 'Plastic', 'Metal', 'Glass', 'Protective', 'Labels']
};

// Supplier name parts categorized by product category
const SUPPLIER_PARTS_BY_CATEGORY = {
  'Electronics': {
    middles: ['Electronics', 'IT', 'Telecom', 'Digital', 'Power', 'Energy'],
    suffixes: ['Systems', 'Tech', 'Solutions', 'Labs', 'Networks', 'Corp', 'Global']
  },
  'Mechanical Parts': {
    middles: ['Engineering', 'Industrial', 'Mechanicals', 'Steel', 'Automotive'],
    suffixes: ['Parts', 'Industries', 'Works', 'Manufacturing', 'Alloys', 'Tools']
  },
  'Raw Materials': {
    middles: ['Chemicals', 'Mining', 'Resources', 'Steel', 'Cement', 'Agro'],
    suffixes: ['Supplies', 'Commodities', 'Group', 'Enterprises', 'Metals', 'Plastics']
  },
  'Office Supplies': {
    middles: ['Global', 'Realty', 'Infrastructure', 'Services', 'Corporate'],
    suffixes: ['Supplies', 'Solutions', 'Stationery', 'Enterprises', 'Traders', 'PvtLtd']
  },
  'Industrial Tools': {
    middles: ['Industrial', 'Engineering', 'Tools', 'Power', 'Infrastructure'],
    suffixes: ['Manufacturing', 'Solutions', 'Industries', 'Works', 'Paints', 'Systems']
  },
  'Safety Gear': {
    middles: ['Industrial', 'Safety', 'Global', 'Engineering', 'Protective'],
    suffixes: ['Supplies', 'Solutions', 'Industries', 'Group', 'Services', 'Ventures']
  },
  'Automotive Parts': {
    middles: ['Automotive', 'Engineering', 'Motors', 'Steel', 'Alloys'],
    suffixes: ['Parts', 'Industries', 'Manufacturing', 'Systems', 'Ventures', 'Associates']
  },
  'Textiles': {
    middles: ['Textiles', 'Fabrics', 'Garments', 'Agro', 'Global'],
    suffixes: ['Fabrics', 'Mills', 'Exports', 'Group', 'TradingCo', 'LLP']
  },
  'FMCG': {
    middles: ['Foods', 'Beverages', 'Agro', 'Retail', 'Global'],
    suffixes: ['Beverages', 'Packaging', 'Supplies', 'Traders', 'Group', 'Retail']
  },
  'Packaging': {
    middles: ['Infrastructure', 'Industrial', 'Logistics', 'Global'],
    suffixes: ['Packaging', 'Solutions', 'Plastics', 'Supplies', 'Polymers', 'Constructions']
  },
  'Default': {
    middles: ['Global', 'Industrial', 'Engineering', 'Finance', 'Realty'],
    suffixes: ['Logistics', 'Supplies', 'Group', 'Enterprises', 'Ventures', 'TradingCo']
  }
};

// Indian first / last names
const FIRST_NAMES = [
  'Aarav','Vivaan','Aditya','Vihaan','Arjun','Sai','Krishna','Ishaan','Rohan','Kabir',
  'Saanvi','Aanya','Diya','Pari','Navya','Anaya','Aarohi','Ira','Meera','Myra',
  'Riya','Sneha','Pooja','Kavya','Nisha','Prisha','Tanvi','Aditi','Anjali','Shreya',
  'Amit','Anil','Rakesh','Suresh','Ravi','Siddharth','Rahul','Kunal','Vikram','Pranav'
];

const LAST_NAMES = [
  'Sharma','Verma','Iyer','Menon','Reddy','Naidu','Patel','Desai','Chopra','Kapoor',
  'Bhatia','Khanna','Malhotra','Mishra','Pandey','Tripathi','Singh','Rajput','Gupta','Agarwal',
  'Mehta','Joshi','Kulkarni','Gowda','Shetty','Pillai','Nair','Das','Chatterjee','Mukherjee'
];

// Enhanced warehouse and retail data
const REGIONS = ['North', 'South', 'East', 'West', 'Central'];
const WAREHOUSE_PREFIXES = ['Distribution Center', 'Logistics Hub', 'Storage Facility', 'Warehouse', 'Fulfillment Center', 'Depot', 'Transit Hub'];

// Retail store types and names
const RETAIL_STORE_CHAINS = {
  'Electronics': ['Reliance Digital', 'Croma', 'Vijay Sales', 'Ezone', 'Poorvika Mobiles', 'Sangeetha Mobiles'],
  'FMCG': ['Big Bazaar', 'More Megastore', 'Spencer\'s Retail', 'HyperCity', 'Star Bazaar', 'D-Mart'],
  'Fashion': ['Lifestyle', 'Central', 'Shoppers Stop', 'Westside', 'Brand Factory', 'Max Fashion'],
  'Home & Furniture': ['HomeTown', 'Urban Ladder', 'Pepperfry Store', 'Godrej Interio', 'Nilkamal', 'Damro'],
  'Automotive': ['Mahindra First Choice', 'Maruti True Value', 'Hyundai SmartCare', 'TVS Motor', 'Hero MotoCorp'],
  'General': ['Vishal Mega Mart', 'V-Mart', 'Easy Day', 'Spar', 'Nature\'s Basket', 'FoodWorld']
};

const INDIAN_CITIES = [
  'Mumbai','Delhi','Bengaluru','Hyderabad','Ahmedabad','Chennai','Kolkata','Pune','Jaipur','Lucknow',
  'Kanpur','Nagpur','Indore','Thane','Bhopal','Visakhapatnam','Patna','Vadodara','Ghaziabad','Ludhiana',
  'Agra','Nashik','Faridabad','Meerut','Rajkot','Kalyan','Vasai','Varanasi','Srinagar','Aurangabad',
  'Dhanbad','Amritsar','Allahabad','Ranchi','Coimbatore','Jodhpur','Madurai','Raipur','Kota','Guwahati'
];

// City to region mapping
const CITY_REGIONS = {
  'Mumbai': 'West', 'Pune': 'West', 'Ahmedabad': 'West', 'Rajkot': 'West', 'Vadodara': 'West', 'Nashik': 'West',
  'Delhi': 'North', 'Jaipur': 'North', 'Lucknow': 'North', 'Kanpur': 'North', 'Ludhiana': 'North', 'Amritsar': 'North',
  'Chennai': 'South', 'Bengaluru': 'South', 'Hyderabad': 'South', 'Coimbatore': 'South', 'Madurai': 'South', 'Visakhapatnam': 'South',
  'Kolkata': 'East', 'Bhubaneswar': 'East', 'Guwahati': 'East', 'Ranchi': 'East', 'Patna': 'East',
  'Bhopal': 'Central', 'Indore': 'Central', 'Nagpur': 'Central', 'Raipur': 'Central'
};

// Product names by category
const PRODUCT_NAMES = {
  'Electronics': {
    'Televisions': ['LED TV', 'OLED TV', 'Smart TV', 'QLED TV', '4K TV'],
    'Mobile Phones': ['Smartphone', 'Feature Phone', 'Gaming Phone', '5G Phone'],
    'Laptops': ['Business Laptop', 'Gaming Laptop', 'Ultrabook', 'Chromebook'],
    'Audio Systems': ['Bluetooth Speaker', 'Soundbar', 'Headphones', 'Earbuds'],
    'Gaming Consoles': ['PlayStation', 'Xbox', 'Nintendo Switch', 'Gaming Controller'],
    'Smart Watches': ['Fitness Watch', 'Smart Watch', 'Sports Watch', 'Kids Watch']
  },
  'Mechanical Parts': {
    'Bearings': ['Ball Bearing', 'Roller Bearing', 'Thrust Bearing', 'Sleeve Bearing'],
    'Gears': ['Spur Gear', 'Helical Gear', 'Worm Gear', 'Planetary Gear'],
    'Valves': ['Gate Valve', 'Ball Valve', 'Check Valve', 'Butterfly Valve'],
    'Pumps': ['Centrifugal Pump', 'Gear Pump', 'Diaphragm Pump', 'Piston Pump'],
    'Motors': ['AC Motor', 'DC Motor', 'Servo Motor', 'Stepper Motor'],
    'Hydraulics': ['Hydraulic Cylinder', 'Hydraulic Pump', 'Hydraulic Valve', 'Hydraulic Filter']
  }
};

const EMAIL_DOMAINS = ['supplyindia.in','supplychain.co.in','logisticsindia.in','traders.in','industries.co.in'];
const EMAIL_DOMAINS_VARIATIONS = ['gmail.com','yahoo.in','hotmail.com','rediffmail.com','outlook.com']; // Less professional domains

// Status options with variations
const PRODUCT_STATUSES = ['active', 'discontinued'];
const PRODUCT_STATUSES_VARIATIONS = ['Active', 'ACTIVE', 'Discontinued', 'DISCONTINUED', 'inactive', 'obsolete', 'N/A', ''];

const RETAIL_STORE_STATUSES = ['active', 'closed', 'under renovation'];
const RETAIL_STORE_STATUSES_VARIATIONS = ['Active', 'ACTIVE', 'Open', 'Closed', 'CLOSED', 'Under Renovation', 'UNDER RENOVATION', 'Renovating', 'Temporarily Closed', 'N/A', ''];

const SUPPLY_ORDER_STATUSES = ['pending', 'shipped', 'delivered', 'canceled'];
const SUPPLY_ORDER_STATUSES_VARIATIONS = ['Pending', 'PENDING', 'Shipped', 'SHIPPED', 'Delivered', 'DELIVERED', 'Cancelled', 'CANCELLED', 'Canceled', 'In Transit', 'Processing', 'Complete', 'N/A', ''];

// Missing value representations
const MISSING_VALUES = ['N/A', 'NA', 'NULL', '', 'n/a', 'Not Available', '-', 'TBD', 'Unknown'];

// Common typos and misspellings
const COMMON_TYPOS = {
  'Electronics': ['Electroincs', 'Electroncs', 'Elecronics', 'Electrnics'],
  'Industrial': ['Industiral', 'Indusrial', 'Industrial', 'Industriel'],
  'Manufacturing': ['Manufactruing', 'Manufactring', 'Manufcturing', 'Manufacturng'],
  'Solutions': ['Solutons', 'Soltuions', 'Soluions', 'Solutoins'],
  'Engineering': ['Enginering', 'Enginneering', 'Engineerig', 'Enginnering'],
  'Systems': ['Systmes', 'Sysetms', 'Systesm', 'Sytsems'],
  'Services': ['Servies', 'Sevices', 'Servces', 'Serivces']
};

// ==============================================================================
// UTILITIES & RANDOM (optional seedable RNG)
// ==============================================================================
let _rngState = null;

function _initRng(seed) {
  if (seed == null) { _rngState = null; return; }
  _rngState = { a: 1664525, c: 1013904223, m: Math.pow(2, 32), state: seed >>> 0 };
}

function _rand() {
  if (!_rngState) return Math.random();
  _rngState.state = (_rngState.a * _rngState.state + _rngState.c) % _rngState.m;
  return _rngState.state / _rngState.m;
}

function randomInt(min, max) {
  return Math.floor(_rand() * (max - min + 1)) + min;
}

function randomFloat(min, max, decimals = 2) {
  const v = _rand() * (max - min) + min;
  return parseFloat(v.toFixed(decimals));
}

function randomChoice(arr) {
  return arr[Math.floor(_rand() * arr.length)];
}

function randomDate(start, end) {
  return new Date(start.getTime() + _rand() * (end.getTime() - start.getTime()));
}

function pad(num, size) {
  return num.toString().padStart(size, '0');
}

function formatDate(date) {
  return Utilities.formatDate(date, Session.getScriptTimeZone ? Session.getScriptTimeZone() : 'GMT', 'yyyy-MM-dd');
}

function formatDateTime(date) {
  return Utilities.formatDate(date, Session.getScriptTimeZone ? Session.getScriptTimeZone() : 'GMT', 'yyyy-MM-dd HH:mm:ss');
}

function getCityRegion(city) {
  return CITY_REGIONS[city] || randomChoice(REGIONS);
}

// ==============================================================================
// DATA QUALITY FUNCTIONS
// ==============================================================================

function introduceTypo(text) {
  if (!text || typeof text !== 'string') return text;

  const words = text.split(' ');
  const wordToReplace = randomChoice(words);

  if (COMMON_TYPOS[wordToReplace]) {
    const typo = randomChoice(COMMON_TYPOS[wordToReplace]);
    return text.replace(wordToReplace, typo);
  }

  // Generic typo introduction (character swapping, missing letters)
  if (wordToReplace.length > 3) {
    const typoType = randomInt(1, 3);
    let typoWord = wordToReplace;

    switch (typoType) {
      case 1: // Swap two adjacent characters
        const pos = randomInt(0, typoWord.length - 2);
        typoWord = typoWord.slice(0, pos) + typoWord[pos + 1] + typoWord[pos] + typoWord.slice(pos + 2);
        break;
      case 2: // Remove a character
        const removePos = randomInt(1, typoWord.length - 2);
        typoWord = typoWord.slice(0, removePos) + typoWord.slice(removePos + 1);
        break;
      case 3: // Double a character
        const doublePos = randomInt(1, typoWord.length - 1);
        typoWord = typoWord.slice(0, doublePos) + typoWord[doublePos] + typoWord.slice(doublePos);
        break;
    }

    return text.replace(wordToReplace, typoWord);
  }

  return text;
}

function applyCaseInconsistency(text) {
  if (!text || typeof text !== 'string') return text;

  const variations = [
    text.toUpperCase(),           // ALL CAPS
    text.toLowerCase(),           // all lowercase
    text.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' '), // Title Case
    text.split(' ').map(word => Math.random() < 0.5 ? word.toUpperCase() : word.toLowerCase()).join(' '), // Random Case
    text // Original case
  ];

  return randomChoice(variations);
}

function addExtraSpaces(text) {
  if (!text || typeof text !== 'string') return text;

  const variations = [
    ' ' + text,                    // Leading space
    text + ' ',                    // Trailing space
    ' ' + text + ' ',              // Both leading and trailing
    text.replace(/ /g, '  '),      // Double spaces
    text.replace(/ /g, ' ' + ' '), // Multiple spaces between words
  ];

  return randomChoice(variations);
}

function generateInconsistentEmail(name, id, isProfessional = true) {
  const sanitized = name.replace(/[^a-zA-Z0-9]/g, '').toLowerCase().slice(0, 20);

  if (_rand() < CONFIG.DATA_QUALITY.FORMAT_INCONSISTENCY_RATE && !isProfessional) {
    // Use consumer email domains for some entries
    const domain = randomChoice(EMAIL_DOMAINS_VARIATIONS);
    const formats = [
      `${sanitized}${id}@${domain}`,
      `${sanitized}.${id}@${domain}`,
      `${sanitized}_${id}@${domain}`,
      `${sanitized}${randomInt(10, 99)}@${domain}`
    ];
    return randomChoice(formats);
  }

  const domain = randomChoice(EMAIL_DOMAINS);
  return `${sanitized}${id}@${domain}`;
}

function generateInconsistentPhone() {
  const formats = [
    `+91-${randomInt(600, 999)}-${pad(randomInt(0, 9999999), 7)}`,   // Standard format
    `+91${randomInt(6000000000, 9999999999)}`,                       // No separators
    `91-${randomInt(600, 999)}-${pad(randomInt(0, 9999999), 7)}`,    // No + prefix
    `${randomInt(600, 999)}-${pad(randomInt(0, 9999999), 7)}`,       // No country code
    `${randomInt(6000000000, 9999999999)}`,                          // Just numbers
    `(${randomInt(600, 999)}) ${pad(randomInt(0, 9999999), 7)}`,     // US style format
    `+91 ${randomInt(600, 999)} ${pad(randomInt(0, 9999999), 7)}`    // Spaces instead of dashes
  ];

  return randomChoice(formats);
}

function generateInconsistentDate(date) {
  if (_rand() < CONFIG.DATA_QUALITY.FORMAT_INCONSISTENCY_RATE) {
    const formats = [
      Utilities.formatDate(date, Session.getScriptTimeZone ? Session.getScriptTimeZone() : 'GMT', 'dd/MM/yyyy'),
      Utilities.formatDate(date, Session.getScriptTimeZone ? Session.getScriptTimeZone() : 'GMT', 'MM/dd/yyyy'),
      Utilities.formatDate(date, Session.getScriptTimeZone ? Session.getScriptTimeZone() : 'GMT', 'dd-MM-yyyy'),
      Utilities.formatDate(date, Session.getScriptTimeZone ? Session.getScriptTimeZone() : 'GMT', 'yyyy/MM/dd'),
      Utilities.formatDate(date, Session.getScriptTimeZone ? Session.getScriptTimeZone() : 'GMT', 'dd MMM yyyy'),
      formatDate(date) // Standard format
    ];
    return randomChoice(formats);
  }
  return formatDate(date);
}

function getMissingValue() {
  return randomChoice(MISSING_VALUES);
}

function shouldIntroduceMissingValue() {
  return _rand() < CONFIG.DATA_QUALITY.MISSING_VALUE_RATE;
}

function shouldIntroduceTypo() {
  return _rand() < CONFIG.DATA_QUALITY.TYPO_RATE;
}

function shouldApplyCaseInconsistency() {
  return _rand() < CONFIG.DATA_QUALITY.CASE_INCONSISTENCY_RATE;
}

function shouldAddExtraSpaces() {
  return _rand() < CONFIG.DATA_QUALITY.EXTRA_SPACES_RATE;
}

function applyDataQualityIssues(text) {
  if (!text || typeof text !== 'string') return text;

  let result = text;

  if (shouldIntroduceTypo()) {
    result = introduceTypo(result);
  }

  if (shouldApplyCaseInconsistency()) {
    result = applyCaseInconsistency(result);
  }

  if (shouldAddExtraSpaces()) {
    result = addExtraSpaces(result);
  }

  return result;
}

function getInconsistentStatus(standardStatuses, variationStatuses) {
  if (_rand() < CONFIG.DATA_QUALITY.FORMAT_INCONSISTENCY_RATE) {
    return randomChoice(variationStatuses);
  }
  return randomChoice(standardStatuses);
}

// ==============================================================================
// DATA GENERATION FUNCTIONS WITH DATA QUALITY ISSUES
// ==============================================================================

function generateSuppliers(count) {
  console.log(`Generating ${count} suppliers with data quality issues...`);
  const suppliers = [];
  const seen = new Set();
  const mainCategories = Object.keys(PRODUCT_CATEGORIES);
  const suppliersPerCategory = Math.floor(count / mainCategories.length);
  let i = 1;
  const duplicatesToCreate = Math.floor(count * CONFIG.DATA_QUALITY.DUPLICATE_RATE);
  const duplicatesCreated = [];

  while (suppliers.length < count) {
    const categoryIndex = Math.min(Math.floor((i - 1) / suppliersPerCategory), mainCategories.length - 1);
    const category = mainCategories[categoryIndex];
    const parts = SUPPLIER_PARTS_BY_CATEGORY[category] || SUPPLIER_PARTS_BY_CATEGORY['Default'];

    let nameBase = `${randomChoice(SUPPLIER_PREFIXES)} ${randomChoice(parts.middles)} ${randomChoice(parts.suffixes)}`;

    // Apply data quality issues to name
    nameBase = applyDataQualityIssues(nameBase);

    let name = nameBase;
    if (seen.has(name)) {
      name = `${nameBase} #${i}`;
    }

    if (!seen.has(name)) {
      seen.add(name);

      // Generate email with potential issues
      let email = generateInconsistentEmail(name, suppliers.length + 1);
      if (shouldIntroduceMissingValue() && suppliers.length > 100) { // Keep most emails valid for business logic
        email = getMissingValue();
      }

      // Generate phone with format variations
      let phone = generateInconsistentPhone();
      if (shouldIntroduceMissingValue()) {
        phone = getMissingValue();
      }

      suppliers.push([
        suppliers.length + 1,   // supplier_id
        name,                   // supplier_name
        email,                  // contact_email
        phone                   // phone_number
      ]);

      // Create some duplicates with slight variations
      if (duplicatesCreated.length < duplicatesToCreate && _rand() < 0.1) {
        const duplicateName = name + ' ' + randomChoice(['Ltd', 'Pvt Ltd', 'Inc', 'Co']);
        const duplicateEmail = generateInconsistentEmail(duplicateName, suppliers.length + 1000);

        suppliers.push([
          suppliers.length + 1,
          applyDataQualityIssues(duplicateName),
          duplicateEmail,
          generateInconsistentPhone()
        ]);
        duplicatesCreated.push(suppliers.length);
      }
    }
    i++;
    if (i > count * 5) break; // safety break
  }
  return suppliers.slice(0, count); // Ensure we don't exceed requested count
}

function generateProducts(count, supplierCount) {
  console.log(`Generating ${count} products with data quality issues...`);
  const products = [];
  const mainCategories = Object.keys(PRODUCT_CATEGORIES);
  const suppliersPerCategory = Math.floor(supplierCount / mainCategories.length);

  // Enhanced price ranges by category
  const categoryPriceRanges = {
    'Electronics': [5000, 150000],
    'Mechanical Parts': [100, 50000],
    'Raw Materials': [50, 20000],
    'Office Supplies': [100, 25000],
    'Industrial Tools': [500, 100000],
    'Safety Gear': [200, 15000],
    'Automotive Parts': [300, 80000],
    'Textiles': [100, 10000],
    'FMCG': [20, 2000],
    'Packaging': [50, 5000]
  };

  for (let i = 1; i <= count; i++) {
    const mainCategory = randomChoice(mainCategories);
    const subCategories = PRODUCT_CATEGORIES[mainCategory];
    const subCategory = randomChoice(subCategories);

    // Introduce category inconsistencies
    let fullCategory;
    if (_rand() < CONFIG.DATA_QUALITY.FORMAT_INCONSISTENCY_RATE) {
      const variations = [
        `${mainCategory} > ${subCategory}`,      // Standard
        `${mainCategory}>${subCategory}`,        // No spaces
        `${mainCategory} / ${subCategory}`,      // Different separator
        `${mainCategory} - ${subCategory}`,      // Dash separator
        `${mainCategory}|${subCategory}`,        // Pipe separator
        `${applyDataQualityIssues(mainCategory)} > ${applyDataQualityIssues(subCategory)}`, // With typos
      ];
      fullCategory = randomChoice(variations);
    } else {
      fullCategory = `${mainCategory} > ${subCategory}`;
    }

    // Generate product name with potential issues
    let productName;
    if (PRODUCT_NAMES[mainCategory] && PRODUCT_NAMES[mainCategory][subCategory]) {
      const baseName = randomChoice(PRODUCT_NAMES[mainCategory][subCategory]);
      productName = `${baseName} Model-${1000 + i}`;
    } else {
      productName = `${subCategory} Item Model-${1000 + i}`;
    }

    // Apply data quality issues to product name
    productName = applyDataQualityIssues(productName);

    // Generate pricing with potential inconsistencies
    const priceRange = categoryPriceRanges[mainCategory] || [100, 5000];
    let unitCost = randomFloat(priceRange[0], priceRange[1] * 0.7, 2);
    let markup = randomFloat(1.2, 2.0, 2);
    let sellingPrice = randomFloat(unitCost * markup, priceRange[1], 2);

    // Introduce price inconsistencies
    if (_rand() < CONFIG.DATA_QUALITY.PRICE_INCONSISTENCY_RATE) {
      const issueType = randomInt(1, 4);
      switch (issueType) {
        case 1: // Selling price lower than cost price
          sellingPrice = unitCost * randomFloat(0.8, 0.95);
          break;
        case 2: // Unrealistic markup
          sellingPrice = unitCost * randomFloat(5, 20);
          break;
        case 3: // Zero or negative values
          if (_rand() < 0.3) unitCost = 0;
          if (_rand() < 0.2) sellingPrice = randomFloat(-100, -1);
          break;
        case 4: // Extreme precision
          unitCost = parseFloat(unitCost.toFixed(randomInt(3, 6)));
          sellingPrice = parseFloat(sellingPrice.toFixed(randomInt(3, 6)));
          break;
      }
    }

    // Link to appropriate supplier
    const categoryIndex = mainCategories.indexOf(mainCategory);
    const startSupplierId = (categoryIndex * suppliersPerCategory) + 1;
    const endSupplierId = Math.min(startSupplierId + suppliersPerCategory - 1, supplierCount);
    let supplierId = randomInt(startSupplierId, endSupplierId);

    // Sometimes link to wrong supplier (data entry errors)
    if (_rand() < 0.05) {
      supplierId = randomInt(1, supplierCount);
    }

    // Product status with variations
    let status = getInconsistentStatus(PRODUCT_STATUSES, PRODUCT_STATUSES_VARIATIONS);
    if (shouldIntroduceMissingValue() && _rand() < 0.02) {
      status = getMissingValue();
    }

    products.push([
      i,                    // product_id
      productName,          // product_name
      unitCost,            // unit_cost
      sellingPrice,        // selling_price
      supplierId,          // supplier_id
      fullCategory,        // product_category
      status               // status
    ]);
  }
  return products;
}

function generateWarehouses(count) {
  console.log(`Generating ${count} warehouses with data quality issues...`);
  const warehouses = [];
  const seen = new Set();

  for (let i = 1; i <= count; i++) {
    let city = randomChoice(INDIAN_CITIES);
    let region = getCityRegion(city);
    const prefix = randomChoice(WAREHOUSE_PREFIXES);

    // Apply data quality issues to city and region
    city = applyDataQualityIssues(city);

    // Introduce region inconsistencies
    if (_rand() < CONFIG.DATA_QUALITY.FORMAT_INCONSISTENCY_RATE) {
      const regionVariations = ['Northern', 'Southern', 'Eastern', 'Western', 'Centre', 'N', 'S', 'E', 'W', 'C'];
      const regionMap = { 'North': 'Northern', 'South': 'Southern', 'East': 'Eastern', 'West': 'Western', 'Central': 'Centre' };
      region = regionMap[region] || randomChoice(regionVariations);
    }

    let nameBase = `${region} ${prefix}`;
    let name = nameBase;
    if (seen.has(name)) name = `${nameBase} #${i}`;

    // Apply data quality issues to warehouse name
    name = applyDataQualityIssues(name);
    seen.add(name);

    let capacity = randomInt(50000, 2000000);

    // Introduce capacity issues
    if (_rand() < CONFIG.DATA_QUALITY.PRICE_INCONSISTENCY_RATE) {
      const capacityIssues = [0, -1000, 99999999, 1]; // Zero, negative, unrealistic, too small
      capacity = randomChoice(capacityIssues);
    }

    // Sometimes make region missing
    if (shouldIntroduceMissingValue() && _rand() < 0.03) {
      region = getMissingValue();
    }

    warehouses.push([
      i,           // warehouse_id
      name,        // warehouse_name
      city,        // city
      region,      // region
      capacity     // storage_capacity
    ]);
  }
  return warehouses;
}

function generateInventory(count, productCount, warehouseCount) {
  console.log(`Generating ${count} inventory records with data quality issues...`);
  const inventory = [];
  const existingPairs = new Set();
  const startDate = new Date('2023-01-01');
  const endDate = new Date();
  const maxUniquePairs = productCount * warehouseCount;

  if (count > maxUniquePairs) {
    console.warn(`Requested inventory count (${count}) exceeds product×warehouse unique pairs (${maxUniquePairs}).`);
  }

  let attempts = 0;
  for (let i = 1; i <= count; i++) {
    let productId, warehouseId, key;
    do {
      productId = randomInt(1, productCount);
      warehouseId = randomInt(1, warehouseCount);
      key = `${productId}-${warehouseId}`;
      attempts++;
      if (attempts > count * 10) break;
    } while (existingPairs.has(key) && existingPairs.size < maxUniquePairs);
    existingPairs.add(key);

    let quantity = randomInt(0, 10000);

    // Introduce quantity issues
    if (_rand() < CONFIG.DATA_QUALITY.PRICE_INCONSISTENCY_RATE) {
      const quantityIssues = [-100, -1, 999999999, 0.5]; // Negative, unrealistic, decimal
      quantity = randomChoice(quantityIssues);
    }

    let lastStockedDate = generateInconsistentDate(randomDate(startDate, endDate));

    // Sometimes make date missing or invalid
    if (shouldIntroduceMissingValue() && _rand() < 0.05) {
      lastStockedDate = randomChoice([getMissingValue(), '2023-13-01', '2023-02-30', 'Invalid Date', '0000-00-00']);
    }

    inventory.push([
      i,                // inventory_id
      productId,        // product_id
      warehouseId,      // warehouse_id
      quantity,         // quantity_on_hand
      lastStockedDate   // last_stocked_date
    ]);
  }
  return inventory;
}

function generateRetailStores(count) {
  console.log(`Generating ${count} retail stores with data quality issues...`);
  const retailStores = [];
  const storeTypes = Object.keys(RETAIL_STORE_CHAINS);

  for (let i = 1; i <= count; i++) {
    let storeType = randomChoice(storeTypes);
    const chains = RETAIL_STORE_CHAINS[storeType];
    let chain = randomChoice(chains);
    let city = randomChoice(INDIAN_CITIES);
    let region = getCityRegion(city);

    // Apply data quality issues
    chain = applyDataQualityIssues(chain);
    city = applyDataQualityIssues(city);
    storeType = applyDataQualityIssues(storeType);

    // Create store name with location
    const locations = ['Mall', 'High Street', 'Central Plaza', 'City Center', 'Grand Mall', 'Express Avenue'];
    let location = randomChoice(locations);
    location = applyDataQualityIssues(location);

    let storeName = `${chain} - ${location}`;

    // Introduce name format variations
    if (_rand() < CONFIG.DATA_QUALITY.FORMAT_INCONSISTENCY_RATE) {
      const nameFormats = [
        `${chain} - ${location}`,
        `${chain}, ${location}`,
        `${chain} (${location})`,
        `${chain} ${location}`,
        `${location} ${chain}`,
        `${chain} @ ${location}`
      ];
      storeName = randomChoice(nameFormats);
    }

    // Region inconsistencies
    if (_rand() < CONFIG.DATA_QUALITY.FORMAT_INCONSISTENCY_RATE) {
      const regionVariations = ['North India', 'South India', 'East India', 'West India', 'Central India',
                               'Northern', 'Southern', 'Eastern', 'Western', 'Central'];
      region = randomChoice(regionVariations);
    }

    // Store status with variations
    let status = getInconsistentStatus(RETAIL_STORE_STATUSES, RETAIL_STORE_STATUSES_VARIATIONS);
    if (shouldIntroduceMissingValue() && _rand() < 0.03) {
      status = getMissingValue();
    }

    retailStores.push([
      i,           // retail_store_id
      storeName,   // store_name
      city,        // city
      region,      // region
      storeType,   // store_type
      status       // store_status
    ]);
  }
  return retailStores;
}

function generateSupplyOrders(count, productCount, warehouseCount, retailStoreCount) {
  console.log(`Generating ${count} supply orders with data quality issues...`);
  const supplyOrders = [];
  const today = new Date('2025-08-24');
  const startDate = new Date('2022-08-24');

  for (let i = 1; i <= count; i++) {
    let productId = randomInt(1, productCount);
    let warehouseId = randomInt(1, warehouseCount);
    let retailStoreId = randomInt(1, retailStoreCount);

    // Introduce ID inconsistencies (wrong references)
    if (_rand() < 0.02) {
      productId = randomInt(productCount + 1, productCount + 1000); // Non-existent product
    }
    if (_rand() < 0.02) {
      warehouseId = randomInt(warehouseCount + 1, warehouseCount + 100); // Non-existent warehouse
    }
    if (_rand() < 0.02) {
      retailStoreId = randomInt(retailStoreCount + 1, retailStoreCount + 100); // Non-existent store
    }

    let quantity = randomInt(1, 1000);

    // Introduce quantity issues
    if (_rand() < CONFIG.DATA_QUALITY.PRICE_INCONSISTENCY_RATE) {
      const quantityIssues = [0, -5, 999999, 0.5, 1.75]; // Zero, negative, unrealistic, decimals
      quantity = randomChoice(quantityIssues);
    }

    let price = randomFloat(100, 50000, 2);

    // Introduce price issues
    if (_rand() < CONFIG.DATA_QUALITY.PRICE_INCONSISTENCY_RATE) {
      const priceIssues = [0, -100, 9999999, 0.01]; // Zero, negative, unrealistic, too low
      price = randomChoice(priceIssues);
    }

    let totalInvoice = parseFloat((quantity * price).toFixed(2));

    // Sometimes make invoice calculation wrong
    if (_rand() < 0.03) {
      totalInvoice = totalInvoice * randomFloat(0.5, 2.5); // Wrong calculation
      totalInvoice = parseFloat(totalInvoice.toFixed(2));
    }

    let orderDate = randomDate(startDate, today);

    // Status logic with data quality issues
    const diffDays = Math.floor((today - orderDate) / (1000 * 60 * 60 * 24));
    let status = 'pending';
    let shippedDate = null;
    let deliveredDate = null;

    if (diffDays > 14) {
      status = 'delivered';
      shippedDate = new Date(orderDate.getTime() + randomInt(1, 5) * 24 * 60 * 60 * 1000);
      deliveredDate = new Date(shippedDate.getTime() + randomInt(1, 10) * 24 * 60 * 60 * 1000);
      if (deliveredDate > today) deliveredDate = today;
      if (shippedDate > today) shippedDate = today;
    } else if (diffDays > 7) {
      status = randomChoice(['shipped', 'delivered']);
      shippedDate = new Date(orderDate.getTime() + randomInt(1, 5) * 24 * 60 * 60 * 1000);
      if (shippedDate > today) shippedDate = today;
      if (status === 'delivered') {
        deliveredDate = new Date(shippedDate.getTime() + randomInt(1, 10) * 24 * 60 * 60 * 1000);
        if (deliveredDate > today) deliveredDate = today;
      }
    } else {
      status = randomChoice(['pending', 'shipped']);
      if (status === 'shipped') {
        shippedDate = new Date(orderDate.getTime() + randomInt(1, 5) * 24 * 60 * 60 * 1000);
        if (shippedDate > today) shippedDate = today;
      }
    }

    // Introduce date inconsistencies
    if (_rand() < 0.05) {
      // Shipped before ordered, delivered before shipped, etc.
      if (shippedDate && orderDate) {
        shippedDate = new Date(orderDate.getTime() - randomInt(1, 5) * 24 * 60 * 60 * 1000);
      }
      if (deliveredDate && shippedDate) {
        deliveredDate = new Date(shippedDate.getTime() - randomInt(1, 3) * 24 * 60 * 60 * 1000);
      }
    }

    // Apply status variations
    status = getInconsistentStatus(SUPPLY_ORDER_STATUSES, SUPPLY_ORDER_STATUSES_VARIATIONS);
    if (shouldIntroduceMissingValue() && _rand() < 0.02) {
      status = getMissingValue();
    }

    // Format dates with inconsistencies
    let orderDateStr = generateInconsistentDate(orderDate);
    let shippedDateStr = shippedDate ? generateInconsistentDate(shippedDate) : null;
    let deliveredDateStr = deliveredDate ? generateInconsistentDate(deliveredDate) : null;

    // Sometimes make dates missing or invalid
    if (shouldIntroduceMissingValue() && _rand() < 0.03) {
      shippedDateStr = randomChoice([getMissingValue(), 'TBD', 'Pending']);
    }
    if (shouldIntroduceMissingValue() && _rand() < 0.04) {
      deliveredDateStr = randomChoice([getMissingValue(), 'Not Delivered', 'Pending']);
    }

    supplyOrders.push([
      i,                    // supply_order_id
      productId,            // product_id
      warehouseId,          // warehouse_id
      retailStoreId,        // retail_store_id
      quantity,             // quantity
      price,                // price
      totalInvoice,         // total_invoice
      orderDateStr,         // order_date
      shippedDateStr,       // shipped_date
      deliveredDateStr,     // delivered_date
      status                // status
    ]);
  }

  return supplyOrders;
}

// ==============================================================================
// SHEET MANAGEMENT & WRITE (BATCHED)
// ==============================================================================

function createOrClearSheet(sheetName, headers) {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = spreadsheet.getSheetByName(sheetName);
  if (sheet) {
    sheet.clear({contentsOnly: true});
  } else {
    sheet = spreadsheet.insertSheet(sheetName);
  }
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight('bold');
  return sheet;
}

function writeDataInBatches(sheet, data, batchSize) {
  const totalRows = data.length;
  if (totalRows === 0) return;
  console.log(`Writing ${totalRows} rows to sheet "${sheet.getName()}" in batches of ${batchSize}...`);
  const startRowBase = 2;
  for (let i = 0; i < totalRows; i += batchSize) {
    const batch = data.slice(i, Math.min(i + batchSize, totalRows));
    const startRow = startRowBase + i;
    sheet.getRange(startRow, 1, batch.length, batch[0].length).setValues(batch);
    SpreadsheetApp.getActive().toast(`Writing ${sheet.getName()}: rows ${startRow}-${startRow + batch.length - 1} (with data quality issues)`, 'Unclean Data Generator', 1);
    Utilities.sleep(50);
  }
  console.log(`Finished writing ${sheet.getName()}.`);
}

// ==============================================================================
// MAIN GENERATION / MENU
// ==============================================================================

function generateAllSupplyChainData() {
  const ui = SpreadsheetApp.getUi();
  ui.alert('Enhanced Supply Chain Generator with Data Quality Issues',
           'Generation will start with realistic data quality problems including:\n\n' +
           '• Inconsistent formatting (ALL CAPS, mixed case, extra spaces)\n' +
           '• Missing values (N/A, NULL, empty fields)\n' +
           '• Typos and spelling mistakes\n' +
           '• Format variations (dates, phones, emails)\n' +
           '• Price inconsistencies\n' +
           '• Duplicate entries\n' +
           '• Invalid references\n\n' +
           'Large datasets may take a few minutes. Please do not close until complete.',
           ui.ButtonSet.OK);

  const startTime = new Date();
  try {
    _initRng(CONFIG.SEED);
    generateSuppliersDataset();
    generateWarehousesDataset();
    generateProductsDataset();
    generateRetailStoresDataset();
    generateInventoryDataset();
    generateSupplyOrdersDataset();

    const duration = (new Date() - startTime) / 1000;
    ui.alert('Unclean Data Generation Complete!',
             `All datasets with realistic data quality issues generated in ${duration.toFixed(1)} seconds!\n\n` +
             `Dataset Sizes:\n` +
             `• Suppliers: ${CONFIG.SUPPLIERS_COUNT}\n` +
             `• Products: ${CONFIG.PRODUCTS_COUNT}\n` +
             `• Warehouses: ${CONFIG.WAREHOUSES_COUNT}\n` +
             `• Inventory: ${CONFIG.INVENTORY_COUNT}\n` +
             `• Retail Stores: ${CONFIG.RETAIL_STORES_COUNT}\n` +
             `• Supply Orders: ${CONFIG.SUPPLY_ORDERS_COUNT}\n\n` +
             `Data Quality Issues Introduced:\n` +
             `• ~${Math.round(CONFIG.DATA_QUALITY.MISSING_VALUE_RATE * 100)}% missing values\n` +
             `• ~${Math.round(CONFIG.DATA_QUALITY.TYPO_RATE * 100)}% typos\n` +
             `• ~${Math.round(CONFIG.DATA_QUALITY.FORMAT_INCONSISTENCY_RATE * 100)}% format issues\n` +
             `• ~${Math.round(CONFIG.DATA_QUALITY.CASE_INCONSISTENCY_RATE * 100)}% case problems\n` +
             `• ~${Math.round(CONFIG.DATA_QUALITY.DUPLICATE_RATE * 100)}% duplicates`,
             ui.ButtonSet.OK);
  } catch (e) {
    console.error('Error generating datasets:', e);
    ui.alert('Error', `Generation failed: ${e.toString()}`, ui.ButtonSet.OK);
  }
}

function generateSuppliersDataset() {
  console.log('=== GENERATING SUPPLIERS WITH DATA QUALITY ISSUES ===');
  const headers = ['supplier_id', 'supplier_name', 'contact_email', 'phone_number'];
  const sheet = createOrClearSheet(CONFIG.SHEET_NAMES.SUPPLIERS, headers);
  const data = generateSuppliers(CONFIG.SUPPLIERS_COUNT);
  writeDataInBatches(sheet, data, CONFIG.BATCH_SIZE);
  console.log('Suppliers dataset completed!');
}

function generateWarehousesDataset() {
  console.log('=== GENERATING WAREHOUSES WITH DATA QUALITY ISSUES ===');
  const headers = ['warehouse_id', 'warehouse_name', 'city', 'region', 'storage_capacity'];
  const sheet = createOrClearSheet(CONFIG.SHEET_NAMES.WAREHOUSES, headers);
  const data = generateWarehouses(CONFIG.WAREHOUSES_COUNT);
  writeDataInBatches(sheet, data, CONFIG.BATCH_SIZE);
  console.log('Warehouses dataset completed!');
}

function generateProductsDataset() {
  console.log('=== GENERATING PRODUCTS WITH DATA QUALITY ISSUES ===');
  const headers = ['product_id', 'product_name', 'unit_cost', 'selling_price', 'supplier_id', 'product_category', 'status'];
  const sheet = createOrClearSheet(CONFIG.SHEET_NAMES.PRODUCTS, headers);
  const data = generateProducts(CONFIG.PRODUCTS_COUNT, CONFIG.SUPPLIERS_COUNT);
  writeDataInBatches(sheet, data, CONFIG.BATCH_SIZE);
  console.log('Products dataset completed!');
}

function generateInventoryDataset() {
  console.log('=== GENERATING INVENTORY WITH DATA QUALITY ISSUES ===');
  const headers = ['inventory_id', 'product_id', 'warehouse_id', 'quantity_on_hand', 'last_stocked_date'];
  const sheet = createOrClearSheet(CONFIG.SHEET_NAMES.INVENTORY, headers);
  const data = generateInventory(CONFIG.INVENTORY_COUNT, CONFIG.PRODUCTS_COUNT, CONFIG.WAREHOUSES_COUNT);
  writeDataInBatches(sheet, data, CONFIG.BATCH_SIZE);
  console.log('Inventory dataset completed!');
}

function generateRetailStoresDataset() {
  console.log('=== GENERATING RETAIL STORES WITH DATA QUALITY ISSUES ===');
  const headers = ['retail_store_id', 'store_name', 'city', 'region', 'store_type', 'store_status'];
  const sheet = createOrClearSheet(CONFIG.SHEET_NAMES.RETAIL_STORES, headers);
  const data = generateRetailStores(CONFIG.RETAIL_STORES_COUNT);
  writeDataInBatches(sheet, data, CONFIG.BATCH_SIZE);
  console.log('Retail Stores dataset completed!');
}

function generateSupplyOrdersDataset() {
  console.log('=== GENERATING SUPPLY ORDERS WITH DATA QUALITY ISSUES ===');
  const headers = ['supply_order_id', 'product_id', 'warehouse_id', 'retail_store_id', 'quantity', 'price', 'total_invoice', 'order_date', 'shipped_date', 'delivered_date', 'status'];
  const sheet = createOrClearSheet(CONFIG.SHEET_NAMES.SUPPLY_ORDERS, headers);
  const data = generateSupplyOrders(CONFIG.SUPPLY_ORDERS_COUNT, CONFIG.PRODUCTS_COUNT, CONFIG.WAREHOUSES_COUNT, CONFIG.RETAIL_STORES_COUNT);
  writeDataInBatches(sheet, data, CONFIG.BATCH_SIZE);
  console.log('Supply Orders dataset completed!');
}
function onOpen() {
  SpreadsheetApp.getUi().createMenu('Data Generator')
    .addItem('Generate All Datasets', 'generateAllSupplyChainData')
    .addSeparator()
    .addItem('Suppliers Only', 'generateSuppliersDataset')
    .addItem('Products Only', 'generateProductsDataset')
    .addItem('Warehouses Only', 'generateWarehousesDataset')
    .addItem('Inventory Only', 'generateInventoryDataset')
    .addItem('Retail Stores Only', 'generateRetailStoresDataset')
    .addItem('Supply Orders Only', 'generateSupplyOrdersDataset')
    .addSeparator()
    .addItem('Configure Data Quality Issues', 'showDataQualityConfig')
    .addToUi();
}


function showDataQualityConfig() {
  const ui = SpreadsheetApp.getUi();
  ui.alert('Data Quality Configuration',
           `Current Data Quality Issue Rates:\n\n` +
           `Missing Values: ${Math.round(CONFIG.DATA_QUALITY.MISSING_VALUE_RATE * 100)}%\n` +
           `Duplicates: ${Math.round(CONFIG.DATA_QUALITY.DUPLICATE_RATE * 100)}%\n` +
           `Typos: ${Math.round(CONFIG.DATA_QUALITY.TYPO_RATE * 100)}%\n` +
           `Format Issues: ${Math.round(CONFIG.DATA_QUALITY.FORMAT_INCONSISTENCY_RATE * 100)}%\n` +
           `Case Problems: ${Math.round(CONFIG.DATA_QUALITY.CASE_INCONSISTENCY_RATE * 100)}%\n` +
           `Extra Spaces: ${Math.round(CONFIG.DATA_QUALITY.EXTRA_SPACES_RATE * 100)}%\n` +
           `Price Issues: ${Math.round(CONFIG.DATA_QUALITY.PRICE_INCONSISTENCY_RATE * 100)}%\n\n` +
           `To modify these rates, edit the CONFIG.DATA_QUALITY section in the code.`,
           ui.ButtonSet.OK);
}

// Optional: helper to quickly run generation with a deterministic seed during testing
function generateWithSeed(seed) {
  CONFIG.SEED = seed;
  generateAllSupplyChainData();
}

// Generate clean data (original functionality)
function generateCleanData() {
  // Temporarily disable data quality issues
  const originalConfig = JSON.parse(JSON.stringify(CONFIG.DATA_QUALITY));
  Object.keys(CONFIG.DATA_QUALITY).forEach(key => {
    CONFIG.DATA_QUALITY[key] = 0;
  });

  generateAllSupplyChainData();

  // Restore original config
  CONFIG.DATA_QUALITY = originalConfig;
}